<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <link rel="stylesheet" href="/css/main.css">
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet"/>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <link href="https://gitcdn.github.io/bootstrap-toggle/2.2.2/css/bootstrap-toggle.min.css" rel="stylesheet">
    <script src="https://gitcdn.github.io/bootstrap-toggle/2.2.2/js/bootstrap-toggle.min.js"></script>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/modules/data.js"></script>
    <script src="https://code.highcharts.com/modules/drilldown.js"></script>

</head>
<style>

    .dropbtn {
        background-color: steelblue;
        color: white;
        padding: 5px;
        font-size: 16px;
        border: none;
        cursor: pointer;
        width: 100px;
        margin-left: 120px;
    }

    .dropdown {
        position: relative;
        display: inline-block;
    }

    .dropdown-content {
        display: none;
        position: absolute;
        background-color: #f9f9f9;
        min-width: 160px;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1;
    }

    .dropdown-content a {
        color: black;
        padding: 12px 16px;
        text-decoration: none;
        display: block;
    }

    .dropdown-content a:hover {background-color: #f1f1f1}

    .dropdown:hover .dropdown-content {
        display: block;
    }

    .dropdown:hover .dropbtn {
        background-color: #3e8e41;
    }

    body{
        width:1160px;
        margin:50px auto;
    }
    path {  stroke: #fff; }
    path:hover {  opacity:0.9; }

    .axis {  font: 10px sans-serif; }
    .legend tr{    border-bottom:1px solid grey; }
    .legend tr:first-child{    border-top:1px solid grey; }

    .axis path,
    .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
    }

    .x.axis path {  display: none; }
    .legend{
        margin-bottom:180px;
        display:inline-block;
        border-collapse: collapse;
        border-spacing: 0px;
    }
    .legend td{
        padding:4px 5px;
        vertical-align:bottom;
    }
    .legendFreq, .legendPerc{
        align:right;
        width:50px;
    }
    .axis { font: 14px sans-serif; }


</style>
<body>


<div class="container_fluid" style="margin-top: 30px">
    <h1 style="text-align: center"> Welcome, <%= name.toUpperCase()%></h1>

    <section class="container text-right">
        <div class="btn-toolbar">
            <button type="button" class="btn btn-primary" onclick="goToHome()">
                <span class="glyphicon glyphicon-home" aria-hidden="true"></span> Home
            </button>
            <button type="button" class="btn btn-primary" onclick="goToLogOut()">LogOut</button>
            <script>
                function goToHome() {
                    location.href = "/personalized_post/1";
                }

                function goToLogOut() {
                    location.href = "/logout";
                }
                function postByTags() {

                    var fired_button = $(this).text();
                    location.href = "/personalized_tag_search/" + fired_button;
                }

            </script>
        </div>
    </section>
    <div class="row" style="margin-top: 50px">
        <div class="col-sm-6 col-md-4">
            <div class="thumbnail" style="background-color: wheat">
                <div class="caption">
                    <h3 style="text-align: center">Profile Tags</h3>
                    <br>
                    <div class="dropdown">
                        <button class="dropbtn" style="color: white;font-size: 16pt"><b><%= user_user_tags.length %></b></button>
                        <div class="dropdown-content">
                            <%function beautifyOutput(input) {
                                var stringInput = input.replace("\"", "").replace("\\", "")
                                stringInput = stringInput.substr(0, stringInput.length - 1)
                                return stringInput;
                            }

                            for (var i=0;i<user_user_tags.length;i++){%>
                            <a value='<%= beautifyOutput(JSON.stringify(user_user_tags[i])) %>'onclick="postByTags.call(this)"><%= beautifyOutput(JSON.stringify(user_user_tags[i]))%></a>
                            <% }%>
                        </div>
                    </div>
                </div>
            </div>

        </div>
        <div class="col-sm-6 col-md-4">
            <div class="thumbnail" style="background-color: wheat">
                <div class="caption">
                    <h3 style="text-align: center">New tags</h3>
                    <br>
                    <div class="dropdown">
                        <button class="dropbtn" style="color: white;font-size: 16pt"><b><%= user_temporary_user_tags.length %></b></button>
                    <div class="dropdown-content">
                        <%function beautifyOutput(input) {
                            var stringInput = input.replace("\"", "").replace("\\", "")
                            stringInput = stringInput.substr(0, stringInput.length - 1)
                            return stringInput;
                        }
                        for (var i=0;i<user_temporary_user_tags.length;i++){%>
                            <a value='<%= beautifyOutput(JSON.stringify(user_temporary_user_tags[i])) %>'onclick="postByTags.call(this)"><%= beautifyOutput(JSON.stringify(user_temporary_user_tags[i].tags))%></a>
                       <% }%>
                    </div>
                    </div>
                </div>
            </div>
            <div style="padding-left: 150px;padding-top: 50px">
            <input  id="osum_button" type="checkbox" checked data-toggle="toggle" data-on="You" data-off="Others" data-onstyle="success" data-offstyle="danger">
            </div>

        </div>
        <div class="col-sm-6 col-md-4">
            <div class="thumbnail" style="background-color: wheat">
                <div class="caption">
                    <h3 style="text-align: center">Favorite Questions</h3>
                    <br>
                    <div class="dropdown">
                        <button class="dropbtn" style="color: white;font-size: 16pt"><b><%= user_favorites.length %></b></button>
                        <div class="dropdown-content">
                            <%function beautifyOutput(input) {
                                var stringInput = input.replace("\"", "").replace("\\", "")
                                stringInput = stringInput.substr(0, stringInput.length - 1)
                                return stringInput;
                            }
                            for (var i=0;i<user_favorites.length;i++){%>
                            <a href="#"><%= beautifyOutput(JSON.stringify(user_favorites[i]))%></a>
                            <% }%>
                        </div>
                    </div>
                </div>
            </div>

        </div>


    </div>
        <div id='dashboard' style="margin-top: 50px;margin-left: 80px">


    </div>
    <div id='dashboard1' style="margin-top: 50px;margin-left: 300px">
    </div>
    <script>
        function dashboard(id, fData){

            var barColor = 'steelblue';
            function segColor(c){ return {UpVotes:"#807dba", DownVotes:"#e08214",TagsClicked:"#41ab5d"}[c]; }

            // compute total for each state.
            fData.forEach(function(d){d.total=d.freq.UpVotes+d.freq.DownVotes+d.freq.TagsClicked;});

            // function to handle histogram.
            function histoGram(fD){
                var hG={},    hGDim = {t: 60, r: 0, b: 20, l: 0};
                hGDim.w = 500 - hGDim.l - hGDim.r,
                    hGDim.h = 300 - hGDim.t - hGDim.b;

                //create svg for histogram.
                var hGsvg = d3.select(id).append("svg")
                    .attr("width", hGDim.w + hGDim.l + hGDim.r)
                    .attr("height", 500).append("g")
                    .attr("transform", "translate(400,0)rotate(90)");

                // create function for x-axis mapping.
                var x = d3.scale.ordinal().rangeRoundBands([0, hGDim.w], 0.1)
                    .domain(fD.map(function(d) { return d[0]; }));

                // Add x-axis to the histogram svg.
                hGsvg.append("g").attr("class", "y axis")
                    .attr("transform", "translate(0," + hGDim.h + ")")
                    .call(d3.svg.axis().scale(x).orient("bottom"))
                    .selectAll("text")
                    .style("text-anchor", "end")
                    .attr("dx", "-.8em")
                    .attr("dy", ".15em")
                    .attr("transform", function(d) {
                        return "rotate(-90)"
                    });

                // Create function for y-axis map.
                var y = d3.scale.linear().range([hGDim.h, 0])
                    .domain([0, d3.max(fD, function(d) { return d[1]; })]);

                // Create bars for histogram to contain rectangles and freq labels.
                var bars = hGsvg.selectAll(".bar").data(fD).enter()
                    .append("g").attr("class", "bar");

                //create the rectangles.
                bars.append("rect")
                    .style("hover",'blue')
                    .attr("x", function(d) { return x(d[0]); })
                    .attr("y", function(d) { return y(d[1]); })
                    .attr("width", x.rangeBand())
                    .attr("height", function(d) { return hGDim.h - y(d[1]); })
                    .attr('fill',barColor)
                    .on("mouseover",mouseover)// mouseover is defined below.
                    .on("mouseout",mouseout);
                //Create the frequency labels above the rectangles.
                bars.append("text").text(function(d){ return d3.format(",")(d[1])})
                    .attr("x", function(d) { return x(d[0])+x.rangeBand()/2; })
                    .attr("y", function(d) { return y(d[1])-5; })
                    .attr("text-anchor", "middle");

                function mouseover(d){  // utility function to be called on mouseover.
                    // filter for selected state.
                    var st = fData.filter(function(s){ return s.State == d[0];})[0],
                        nD = d3.keys(st.freq).map(function(s){ return {type:s, freq:st.freq[s]};});

                    // call update functions of pie-chart and legend.
                    pC.update(nD);
                    leg.update(nD);
                }

                function mouseout(d){    // utility function to be called on mouseout.
                    // reset the pie-chart and legend.
                    pC.update(tF);
                    leg.update(tF);
                }

                // create function to update the bars. This will be used by pie-chart.
                hG.update = function(nD, color){
                    // update the domain of the y-axis map to reflect change in frequencies.
                    y.domain([0, d3.max(nD, function(d) { return d[1]; })]);

                    // Attach the new data to the bars.
                    var bars = hGsvg.selectAll(".bar").data(nD);

                    // transition the height and color of rectangles.
                    bars.select("rect").transition().duration(500)
                        .attr("y", function(d) {return y(d[1]); })
                        .attr("height", function(d) { return hGDim.h - y(d[1]); })
                        .attr("fill", color);

                    // transition the frequency labels location and change value.
                    bars.select("text").transition().duration(500)
                        .text(function(d){ return d3.format(",")(d[1])})
                        .attr("y", function(d) {return y(d[1])-5; });
                }
                return hG;
            }

            // function to handle pieChart.
            function pieChart(pD){
                var pC ={},    pieDim ={w:250, h: 250};
                pieDim.r = Math.min(pieDim.w, pieDim.h) / 2;

                // create svg for pie chart.
                var piesvg = d3.select(id).append("svg")
                    .attr("width", 290).attr("height", 400).append("g")
                    .attr("transform", "translate(150,150)");

                // create function to draw the arcs of the pie slices.
                var arc = d3.svg.arc().outerRadius(pieDim.r - 10).innerRadius(0);

                // create a function to compute the pie slice angles.
                var pie = d3.layout.pie().sort(null).value(function(d) { return d.freq; });

                // Draw the pie slices.
                piesvg.selectAll("path").data(pie(pD)).enter().append("path").attr("d", arc)
                    .each(function(d) { this._current = d; })
                    .style("fill", function(d) { return segColor(d.data.type); })
                    .on("mouseover",mouseover).on("mouseout",mouseout);

                // create function to update pie-chart. This will be used by histogram.
                pC.update = function(nD){
                    piesvg.selectAll("path").data(pie(nD)).transition().duration(500)
                        .attrTween("d", arcTween);
                }
                // Utility function to be called on mouseover a pie slice.
                function mouseover(d){
                    // call the update function of histogram with new data.
                    hG.update(fData.map(function(v){
                        return [v.State,v.freq[d.data.type]];}),segColor(d.data.type));
                }
                //Utility function to be called on mouseout a pie slice.
                function mouseout(d){
                    // call the update function of histogram with all data.
                    hG.update(fData.map(function(v){
                        return [v.State,v.total];}), barColor);
                }
                // Animating the pie-slice requiring a custom function which specifies
                // how the intermediate paths should be drawn.
                function arcTween(a) {
                    var i = d3.interpolate(this._current, a);
                    this._current = i(0);
                    return function(t) { return arc(i(t));    };
                }
                return pC;
            }

            // function to handle legend.
            function legend(lD){
                var leg = {};

                // create table for legend.
                var legend = d3.select(id).append("table").attr('class','legend');

                // create one row per segment.
                var tr = legend.append("tbody").selectAll("tr").data(lD).enter().append("tr");

                // create the first column for each segment.
                tr.append("td").append("svg").attr("width", '16').attr("height", '16').append("rect")
                    .attr("width", '50').attr("height", '30')
                    .attr("fill",function(d){ return segColor(d.type); });

                // create the second column for each segment.
                tr.append("td").text(function(d){ return d.type;})
                    .attr("width", '50').attr("height", '30');

                // create the third column for each segment.
                tr.append("td").attr("class",'legendFreq')
                    .text(function(d){ return d3.format(",")(d.freq);})
                    .attr("width", '50').attr("height", '30');

                // create the fourth column for each segment.
                tr.append("td").attr("class",'legendPerc')
                    .text(function(d){ return getLegend(d,lD);})
                    .attr("width", '50').attr("height", '30');

                // Utility function to be used to update the legend.
                leg.update = function(nD){
                    // update the data attached to the row elements.
                    var l = legend.select("tbody").selectAll("tr").data(nD);

                    // update the frequencies.
                    l.select(".legendFreq").text(function(d){ return d3.format(",")(d.freq);});

                    // update the percentage column.
                    l.select(".legendPerc").text(function(d){ return getLegend(d,nD);});
                }

                function getLegend(d,aD){ // Utility function to compute percentage.
                    return d3.format("%")(d.freq/d3.sum(aD.map(function(v){ return v.freq; })));
                }

                return leg;
            }

            // calculate total frequency by segment for all state.
            var tF = ['UpVotes','DownVotes','TagsClicked'].map(function(d){
                return {type:d, freq: d3.sum(fData.map(function(t){ return t.freq[d];}))};
            });

            // calculate total frequency by state for all segment.
            var sF = fData.map(function(d){return [d.State,d.total];});

            var hG = histoGram(sF), // create the histogram.
                pC = pieChart(tF), // create the pie-chart.
                leg= legend(tF);  // create the legend.
        }
    </script>
    <script>
        'use strict';
        (function (factory) {
            if (typeof module === 'object' && module.exports) {
                module.exports = factory;
            } else {
                factory(Highcharts);
            }
        }(function (Highcharts) {
            (function (H) {
                /**
                 * (c) 2016 Highsoft AS
                 * Authors: Jon Arild Nygard
                 *
                 * License: www.highcharts.com/license
                 *
                 * This is an experimental Highcharts module which enables visualization
                 * of a word cloud.
                 */
                var each = H.each,
                    extend = H.extend,
                    Series = H.Series;

                /**
                 * isRectanglesIntersecting - Detects if there is a collision between two
                 *     rectangles.
                 *
                 * @param  {object} r1 First rectangle.
                 * @param  {object} r2 Second rectangle.
                 * @return {boolean} Returns true if the rectangles overlap.
                 */
                var isRectanglesIntersecting = function isRectanglesIntersecting(r1, r2) {
                    return !(
                        r2.left > r1.right ||
                        r2.right < r1.left ||
                        r2.top > r1.bottom ||
                        r2.bottom < r1.top
                    );
                };

                /**
                 * intersectsAnyWord - Detects if a word collides with any previously placed
                 *     words.
                 *
                 * @param  {Point} point Point which the word is connected to.
                 * @param  {Array} points Previously placed points to check against.
                 * @return {boolean} Returns true if there is collision.
                 */
                var intersectsAnyWord = function intersectsAnyWord(point, points) {
                    var intersects = false,
                        rect1 = point.rect,
                        rect2;
                    if (point.lastCollidedWith) {
                        rect2 = point.lastCollidedWith.rect;
                        intersects = isRectanglesIntersecting(rect1, rect2);
                        // If they no longer intersects, remove the cache from the point.
                        if (!intersects) {
                            delete point.lastCollidedWith;
                        }
                    }
                    if (!intersects) {
                        intersects = !!H.find(points, function (p) {
                            var result;
                            rect2 = p.rect;
                            result = isRectanglesIntersecting(rect1, rect2);
                            if (result) {
                                point.lastCollidedWith = p;
                            }
                            return result;
                        });
                    }
                    return intersects;
                };

                /**
                 * archimedeanSpiral - Gives a set of cordinates for an Archimedian Spiral.
                 *
                 * @param  {type} t How far along the spiral we have traversed.
                 * @return {object} Resulting coordinates, x and y.
                 */
                var archimedeanSpiral = function archimedeanSpiral(t) {
                    t *= 0.1;
                    return {
                        x: t * Math.cos(t),
                        y: t * Math.sin(t)
                    };
                };

                /**
                 * getRandomPosition
                 *
                 * @param  {number} size
                 * @return {number}
                 */
                var getRandomPosition = function getRandomPosition(size) {
                    return Math.round((size * (Math.random() + 0.5)) / 2);
                };

                /**
                 * getScale - Calculates the proper scale to fit the cloud inside the plotting
                 *     area.
                 *
                 * @param  {number} targetWidth  Width of target area.
                 * @param  {number} targetHeight Height of target area.
                 * @param  {object} field The playing field.
                 * @param  {Series} series Series object.
                 * @return {number} Returns the value to scale the playing field up to the size
                 *     of the target area.
                 */
                var getScale = function getScale(targetWidth, targetHeight, field, series) {
                    var box = series.group.getBBox(),
                        f = {
                            left: box.x,
                            right: box.x + box.width,
                            top: box.y,
                            bottom: box.y + box.height
                        },
                        height = Math.max(Math.abs(f.top), Math.abs(f.bottom)) * 2,
                        width = Math.max(Math.abs(f.left), Math.abs(f.right)) * 2,
                        scaleX = 1 / width * targetWidth,
                        scaleY = 1 / height * targetHeight;
                    return Math.min(scaleX, scaleY);
                };

                /**
                 * getPlayingField - Calculates what is called the playing field.
                 *    The field is the area which all the words are allowed to be positioned
                 *    within. The area is proportioned to match the target aspect ratio.
                 *
                 * @param  {number} targetWidth Width of the target area.
                 * @param  {number} targetHeight Height of the target area.
                 * @return {object} The width and height of the playing field.
                 */
                var getPlayingField = function getPlayingField(targetWidth, targetHeight) {
                    var ratio = targetWidth / targetHeight;
                    return {
                        width: 256 * ratio,
                        height: 256
                    };
                };


                /**
                 * getRotation - Calculates a number of degrees to rotate, based upon a number
                 *     of orientations within a range from-to.
                 *
                 * @param  {type} orientations Number of orientations.
                 * @param  {type} from The smallest degree of rotation.
                 * @param  {type} to The largest degree of rotation.
                 * @return {type} Returns the resulting rotation for the word.
                 */
                var getRotation = function getRotation(orientations, from, to) {
                    var range = to - from,
                        intervals = range / (orientations - 1),
                        orientation = Math.floor(Math.random() * orientations);
                    return from + (orientation * intervals);
                };

                /**
                 * outsidePlayingField - Detects if a word is placed outside the playing field.
                 *
                 * @param  {Point} point Point which the word is connected to.
                 * @param  {object} field The width and height of the playing field.
                 * @return {boolean} Returns true if the word is placed outside the field.
                 */
                var outsidePlayingField = function outsidePlayingField(point, field) {
                    var rect = point.graphic.getBBox(),
                        playingField = {
                            left: -(field.width / 2),
                            right: field.width / 2,
                            top: -(field.height / 2),
                            bottom: field.height / 2
                        };
                    return !(
                        playingField.left < rect.x &&
                        playingField.right > (rect.x + rect.width) &&
                        playingField.top < rect.y &&
                        playingField.bottom > (rect.y + rect.height)
                    );
                };

                /**
                 * Default options for the WordCloud series.
                 */
                var WordCloudOptions = {
                    borderWidth: 0,
                    clip: false, // Something goes wrong with clip. // TODO fix this
                    colorByPoint: true,
                    fontFamily: 'Impact',
                    placementStrategy: 'random',
                    rotation: {
                        from: 0,
                        orientations: 2,
                        to: 90
                    },
                    showInLegend: false,
                    spiral: 'archimedean',
                    tooltip: {
                        followPointer: true
                    }
                };

                /**
                 * Properties of the WordCloud series.
                 */
                var WordCloudSeries = {
                    animate: Series.prototype.animate,
                    bindAxes: function () {
                        var wordcloudAxis = {
                            endOnTick: false,
                            gridLineWidth: 0,
                            lineWidth: 0,
                            maxPadding: 0,
                            startOnTick: false,
                            title: null,
                            tickPositions: []
                        };
                        Series.prototype.bindAxes.call(this);
                        extend(this.yAxis.options, wordcloudAxis);
                        extend(this.xAxis.options, wordcloudAxis);
                    },
                    /**
                     * deriveFontSize - Calculates the fontSize of a word based on its weight.
                     *
                     * @param  {number} relativeWeight The weight of the word, on a scale 0-1.
                     * @return {number} Returns the resulting fontSize of a word.
                     */
                    deriveFontSize: function deriveFontSize(relativeWeight) {
                        var maxFontSize = 25;
                        return Math.floor(maxFontSize * relativeWeight);
                    },
                    drawPoints: function () {
                        var series = this,
                            xAxis = series.xAxis,
                            yAxis = series.yAxis,
                            chart = series.chart,
                            placed = [],
                            placementStrategy = series.placementStrategy[series.options.placementStrategy],
                            spiral = series.spirals[series.options.spiral],
                            rotation = series.options.rotation,
                            scale,
                            weights = series.points
                                .map(function (p) {
                                    return p.weight;
                                }),
                            maxWeight = Math.max.apply(null, weights),
                            field = getPlayingField(xAxis.len, yAxis.len),
                            maxDelta = (field.width * field.width) + (field.height * field.height),
                            data = series.points
                                .sort(function (a, b) {
                                    return b.weight - a.weight; // Sort descending
                                });
                        each(data, function (point) {
                            var attempt = 0,
                                delta,
                                spiralIsSmallish = true,
                                placement,
                                clientRect,
                                rect;
                            point.relativeWeight = 1 / maxWeight * point.weight;
                            placement = placementStrategy(point, {
                                data: data,
                                field: field,
                                placed: placed,
                                rotation: rotation
                            });
                            if (!point.graphic) {
                                point.graphic = chart.renderer.text(point.name).css({
                                    fontSize: series.deriveFontSize(point.relativeWeight),
                                    fill: point.color,
                                    fontFamily: series.options.fontFamily
                                }).attr({
                                    x: placement.x,
                                    y: placement.y,
                                    'text-anchor': 'middle',
                                    rotation: placement.rotation
                                }).add(series.group);
                                // Cache the original DOMRect values for later calculations.
                                point.clientRect = clientRect = extend({},
                                    point.graphic.element.getBoundingClientRect()
                                );
                                point.rect = rect = extend({}, clientRect);
                            }
                            /**
                             * while w intersects any previously placed words:
                             *    do {
                     *      move w a little bit along a spiral path
                     *    } while any part of w is outside the playing field and
                             *        the spiral radius is still smallish
                             */
                            while (
                                (
                                    intersectsAnyWord(point, placed) ||
                                    outsidePlayingField(point, field)
                                ) && spiralIsSmallish
                                ) {
                                delta = spiral(attempt);
                                // Update the DOMRect with new positions.
                                rect.left = clientRect.left + delta.x;
                                rect.right = rect.left + rect.width;
                                rect.top = clientRect.top + delta.y;
                                rect.bottom = rect.top + rect.height;
                                spiralIsSmallish = (
                                    Math.min(Math.abs(delta.x), Math.abs(delta.y)) < maxDelta
                                );
                                attempt++;
                            }
                            /**
                             * Check if point was placed, if so delete it,
                             * otherwise place it on the correct positions.
                             */
                            if (spiralIsSmallish) {
                                point.graphic.attr({
                                    x: placement.x + (delta ? delta.x : 0),
                                    y: placement.y + (delta ? delta.y : 0)
                                });
                                placed.push(point);
                            } else {
                                point.graphic = point.graphic.destroy();
                            }
                        });
                        /**
                         * Scale the series group to fit within the plotArea.
                         */
                        scale = getScale(xAxis.len, yAxis.len, field, series);
                        series.group.attr({
                            scaleX: scale,
                            scaleY: scale
                        });
                    },
                    /**
                     * Strategies used for deciding rotation and initial position of a word.
                     * To implement a custom strategy, have a look at the function
                     *     randomPlacement for example.
                     */
                    placementStrategy: {
                        random: function randomPlacement(point, options) {
                            var field = options.field,
                                r = options.rotation;
                            return {
                                x: getRandomPosition(field.width) - (field.width / 2),
                                y: getRandomPosition(field.height) - (field.height / 2),
                                rotation: getRotation(r.orientations, r.from, r.to)
                            };
                        }
                    },
                    /**
                     * Spirals used for placing a word after the inital position experienced a
                     *     collision with either another word or the borders.
                     * To implement a custom spiral, look at the function archimedeanSpiral for
                     *    example.
                     */
                    spirals: {
                        'archimedean': archimedeanSpiral
                    },
                    getPlotBox: function () {
                        var series = this,
                            chart = series.chart,
                            inverted = chart.inverted,
                            // Swap axes for inverted (#2339)
                            xAxis = series[(inverted ? 'yAxis' : 'xAxis')],
                            yAxis = series[(inverted ? 'xAxis' : 'yAxis')],
                            width = xAxis ? xAxis.len : chart.plotWidth,
                            height = yAxis ? yAxis.len : chart.plotHeight,
                            x = xAxis ? xAxis.left : chart.plotLeft,
                            y = yAxis ? yAxis.top : chart.plotTop;
                        return {
                            translateX: x + (width / 2),
                            translateY: y + (height / 2),
                            scaleX: 1, // #1623
                            scaleY: 1
                        };
                    }
                };

                /**
                 * Assemble the WordCloud series type.
                 */
                H.seriesType('wordcloud', 'column', WordCloudOptions, WordCloudSeries);

            }(Highcharts));
        }));


        function word_cloud(container, H, text, activity, user) {
            var data = text
                .split(',').join('') // remove commas
                .split('.').join('') // remove periods
                .split(' ') // split into words
                .reduce(function (arr, word) {
                    var obj = arr.find(function (obj) {
                        return obj.name === word;
                    });
                    if (obj) {
                        obj.weight += 1;
                    } else {
                        obj = {
                            name: word,
                            weight: 1
                        };
                        arr.push(obj);
                    }
                    return arr;
                }, []);
            H.chart(container, {
                chart: {
                    width: 600,
                    height: 600,
                    plotBorderWidth: 1
                },
                credits: {
                    enabled: false
                },

                series: [{
                    type: 'wordcloud',
                    data: data
                }],
                title: {
                    text: user + ' Word-Cloud Activity: ' + activity
                }
            });
        }

    </script>


    <script>
        <% var upvoted_tags=[],downvoted_tags=[],temp_tags=[],data=[];
        for (var i=0;i<user_up_voted.length;i++){

            upvoted_tags.push(user_up_voted[i].tags)

        }
        for (var i=0;i<user_down_voted.length;i++){

            downvoted_tags.push(user_down_voted[i].tags)

        }
        for (var i=0;i<user_temporary_user_tags.length;i++){

            temp_tags.push(user_temporary_user_tags[i].tags)

        }
        function onlyUnique(value, index, self) {
            return self.indexOf(value) === index;
        }
        var combined=upvoted_tags.concat(downvoted_tags).concat(temp_tags)
        var unique_tags=combined.filter(onlyUnique)
        for(var i=0;i<unique_tags.length;i++) {

            var temp_data = {}
            var counts = {}
            temp_data['State'] = unique_tags[i]
            if (!(upvoted_tags.includes(unique_tags[i]))) {
                counts['UpVotes'] = 0
            } else {
                var index = upvoted_tags.indexOf(unique_tags[i])
                counts['UpVotes'] = user_up_voted[index].count
            }
            if (!(downvoted_tags.includes(unique_tags[i]))) {
                counts['DownVotes'] = 0
            } else {
                var index = downvoted_tags.indexOf(unique_tags[i])
                counts['DownVotes'] = user_down_voted[index].count
            }
            if (!(temp_tags.includes(unique_tags[i]))) {
                counts['TagsClicked'] = 0
            } else {
                var index = temp_tags.indexOf(unique_tags[i])
                counts['TagsClicked'] = user_temporary_user_tags[index].count
            }
            temp_data['freq']=counts
            data.push(temp_data)




        }
        var others_upvoted_tags=[],others_downvoted_tags=[],others_temp_tags=[];

        for (var i=0;i<users_up_voted.length;i++){

            others_upvoted_tags.push(users_up_voted[i].tags)

        }

        for (var i=0;i<users_down_voted.length;i++){

            others_downvoted_tags.push(users_down_voted[i].tags)

        }
        for (var i=0;i<users_temporary_user_tags.length;i++){

            others_temp_tags.push(users_temporary_user_tags[i].tags)

        }
        var others_combined=others_upvoted_tags.concat(others_downvoted_tags).concat(others_temp_tags)
        var other_unique_tags=others_combined.filter(onlyUnique)
        var str=""
        for(var i=1;i<other_unique_tags.length;i++){
            str+=other_unique_tags[i]+" "
        }

        %>
        myData=[]
        myData=JSON.parse('<%-JSON.stringify(data)%>')
        othersData=<%-JSON.stringify(str)%>
        console.log(typeof(othersData));
        dashboard('#dashboard',myData);

        $("#osum_button").change(function(){
            if($(this).prop("checked") == true){
                $("#dashboard1 div").html('')
                dashboard('#dashboard',myData);
            }else{
                d3.selectAll("svg").remove();
                d3.selectAll("g").remove();
                d3.select("table").remove();
                word_cloud('dashboard1', Highcharts, othersData, "", "");

            }
        });

    </script>



</div>
</body>
</html>